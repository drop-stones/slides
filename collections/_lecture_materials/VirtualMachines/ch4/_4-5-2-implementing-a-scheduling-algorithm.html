<h3 class="subsection-title" id="4-5-2-title">4.5.2 Implementing a Scheduling Algorithm</h3>

<p>
  In this subsection, we consider a complete code-scheduling algorithm.<br>
  This algorithm have the following properties:
</p>

<ul>
  <li>Optimization granularity: superblock</li>
  <li>
    Register states are always recoverable.
    <ul>
      <li><em>Register live ranges</em> are extended by backups.</li>
    </ul>
  </li>
  <li>
    Handling precise traps:
    <ol>
      <li>Recover the original register state at the <em>checkpoint</em>.</li>
      <li>Interpret the original source code from the <em>checkpoint</em>.</li>
    </ol>
  </li>
</ul>

<p>We will use the translations from IA-32 to PowerPC as an example.</p>

<div class="flex-container">
  <div>Original Source Code: <br>{% highlight nasm %}{{ original-source-code }}{% endhighlight %}</div>
</div>

<h4 class="part-title">Step 1: Translate to Single-Assignment Form</h4>

<h4 class="part-title">Step 2: Form Register Map</h4>

<h4 class="part-title">Step 3: Reorder Code</h4>

<h4 class="part-title">Step 4: Determine Checkpoints</h4>

<h4 class="part-title">Step 5: Assign Registers</h4>

<h4 class="part-title">Step 6: Add Compensate Code</h4>

<h4 class="part-title">Precise State Recovery</h4>

<h4 class="part-title">Condition Code Handling</h4>

<h4 class="part-title">Step 5a: Assign Register with Condition Codes</h4>

