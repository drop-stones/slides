<div class="section" id="vm-4-5-code-reordering">
  <h2>4.5 Code Reordering</h2>

  <p><em>Code Reordering</em> is an important optimization because:</p>
  <ul>
    <li>
      In simple pipeline microarchitectures, instructions are executed strictly in program order.
      <ul>
        <li><em>Code Reordering</em> improve pipeline performance.</li>
      </ul>
    </li>
    <li>
      Source binary is not ordered for target processors.
      <ul>
        <li>
          In <a href="https://en.wikipedia.org/wiki/Very_long_instruction_word">VLIW</a> architectures, 
          VLIW processors assume that the compiler reorder instructions to gather independent instructions.
        </li>
      </ul>
    </li>
    <li>
      In dynamic out-of-order <a href="https://en.wikipedia.org/wiki/Superscalar_processor">superscalar processors</a>:
      <ul>
        <li><em>Code Reordering</em> have an effect on functional unit latencies (especially cache memory latencies).</li>
      </ul>
    </li>
  </ul>

  <p>
    Because of <em>code reordering</em>'s importance, we consider it before looking at other optimizations.<br />
    We first discuss several important issues about <em>code reordering</em>.
  </p>

  {% include_relative _4-5-1-primitive-instruction-reordering.html %}
  
  {% include_relative _4-5-2-implementing-a-scheduling-algorithm.html %}
  
  {% include_relative _4-5-3-superblocks-versus-traces.html %}

</div>
<!-- vm-4-5-code-reordering -->
