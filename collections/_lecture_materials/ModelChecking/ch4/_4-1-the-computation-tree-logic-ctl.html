<div id="mc-4-1-the-computation-tree-logic-ctl*">
  <h2>{{ 4-1-title }}</h2>

  <p>In this section, we introduce <em>CTL*</em>, a type of temporal logic.</p>

  <em>CTL* (computation tree logic)</em> defines properties of <em>computation tree</em>:
  <ul>
    <li>
      Convert Kripke structure \( M \) to <em>computation tree</em>.
      <ul><li>unwind \( M \) from the initial state.</li></ul>
    </li>
    <li><em>Computation trees</em> show all possible executions from the initial state.</li>
  </ul>

  <div class="flex-container">
    <div>
      Kripke structure \( M \)
      {% include_relative {{ mermaid_dir }}/kripke-model.html %}
    </div>
    <div>
      Computation Tree of \( M \)
      {% include_relative {{ mermaid_dir }}/unwind-kripke-structure.html %}
    </div>
  </div>

  In Ch.3, we define that the transition relation of \( M \) is <em>left-total</em>:
  <ul>
    <li>Each state has a successor.</li>
    <li>All branches are infinite.</li>
  </ul>

  CTL* formulas are composed of <em>path quantifiers</em> and <em>temporal operators</em>:
  <ul>
    <li>
      <em>Path quantifiers</em>
      <ul>
        <li>
          \( \bm{A} \varphi \) : "all computation paths"
          <ul><li>This means that all paths from a given state have property \( \varphi \)</li></ul>
        </li>
        <li>
          \( \bm{E} \varphi \) : "there exists a computation path"
          <ul><li>This means that at least one path from a given state has property \( \varphi \)</li></ul>
        </li>
      </ul>
    </li>
    <li>
      <em>Temporal operators</em>
      <ul>
        <li>
          \( \bm{X} p \) : "next time \( p \)"
          <ul><li>Intuitively, this requires that proposition \( p \) holds on the second state of the path</li></ul>
        </li>
        <li>
          \( \bm{F} p \) : "eventually \( p \)" or "in the future \( p \)"
          <ul><li>This is used to assert that property \( p \) holds at some state on the path</li></ul>
        </li>
        <li>
          \( \bm{G} p \) : "always \( p \)" or "globally \( p \)"
          <ul><li>This specifies that proposition \( p \) holds at every state on the path</li></ul>
        </li>
        <li>
          \( p \bm{U} q \) : "\( p \) until \( q \)"
          <ul>
            <li>
              It holds if:
              <ul>
                <li>there is a state on the path where the second property \( q \) holds and</li>
                <li>at every preceding state on the path, the first property \( p \) holds.</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>
          \( p \bm{R} q \) : "\( p \) release \( q \)"
          <ul>
            <li>It holds if \( q \) holds along the path up to and including the first state where \( p \) holds.</li>
            <li>\( p \) is not required to eventually hold.</li>
            <li>Logical dual of the \( \bm{U} \)</li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>

  <div class="flex-container">
    {% include_relative {{ mermaid_dir }}/temporal-operator.html %}
  </div>

  <div class="example">
    <h5>Example</h5>
  
    <div class="flex-container">
      <div>
        {% include_relative {{ mermaid_dir }}/unwind-kripke-structure.html %}
        <div class="flex-container">
          <p>
            \( s_0 \) = root state<br>
            \( \pi_0 \) = leftmost path<br>
            \( \pi_1 \) = rightmost path
          </p>
        </div>
      </div>
    </div>

    <ul>
      <li>
        \( \pi_0 \models \bm{G} b \)
        <ul><li>On \( \pi_0 \), property \( b \) holds in every state.</li></ul>
      </li>
      <li>
        \( \pi_1 \not\models \bm{G} b \)
        <ul><li>On \( \pi_1 \), property \( b \) does not hold in every state.</li></ul>
      </li>
      <li>
        \( s_0 \models \bm{EG} b \)
        <ul><li>One path (but not all paths) from the initial state \( s_0 \) satisfy \( \bm{G} b \)</li></ul>
      </li>
      <li>
        \( s_0 \not\models \bm{AG} b \)
        <ul><li>All paths from the initial state \( s_0 \) do not satisfy \( \bm{G} b \)</li></ul>
      </li>
    </ul>

    This example shows that:
    <ul>
      <li>
        <em>Path quantifiers</em> describe properties of a state.
        <ul><li>"Does a certain path start in this state?"</li></ul>
      </li>
      <li>
        <em>Temporal operators</em> describe properties of paths.
        <ul><li>"Can a certain state be reached along this path?"</li></ul>
      </li>
    </ul>
  </div>

</div>
<!-- mc-4-1-the-computation-tree-logic-ctl* -->
